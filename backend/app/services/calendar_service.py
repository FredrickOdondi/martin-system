from google.oauth2 import service_account
import google.auth
from googleapiclient.discovery import build
import logging
import os
from app.core.config import settings
from typing import Dict, Any, Optional
import uuid
import datetime

logger = logging.getLogger(__name__)

class CalendarService:
    SCOPES = ['https://www.googleapis.com/auth/calendar']

    def __init__(self):
        self.creds = None
        self.service = None
        self._initialize_service()

    def _initialize_service(self):
        try:
            # 0. Recover token.json from Env Var (for Railway/Production)
            if not os.path.exists('token.json') and os.environ.get('GOOGLE_TOKEN_JSON'):
                try:
                    logger.info("Restoring token.json from GOOGLE_TOKEN_JSON environment variable...")
                    with open('token.json', 'w') as f:
                        f.write(os.environ.get('GOOGLE_TOKEN_JSON'))
                except Exception as e:
                    logger.error(f"Failed to restore token.json from env: {e}")

            # 1. Try OAuth2 User Token (generated by setup_google_auth.py)
            if os.path.exists('token.json'):
                from google.oauth2.credentials import Credentials
                self.creds = Credentials.from_authorized_user_file('token.json', self.SCOPES)
                logger.info("Using OAuth2 User Credentials (token.json).")
            
            # 2. Start Service Account Logic
            else:
                # Try to grab default credentials (cloud or local ADC)
                # For Service Account, GOOGLE_APPLICATION_CREDENTIALS should be set
                self.creds, project = google.auth.default(scopes=self.SCOPES)
                
                # Check for impersonation (Domain-Wide Delegation)
                # Required for Service Accounts to generate Meet links (needs Workspace license)
                impersonate_email = os.environ.get("GOOGLE_IMPERSONATE_EMAIL")
                if impersonate_email and hasattr(self.creds, 'with_subject'):
                    logger.info(f"Impersonating user: {impersonate_email}")
                    self.creds = self.creds.with_subject(impersonate_email)

            self.service = build('calendar', 'v3', credentials=self.creds)
            logger.info("CalendarService initialized successfully.")
        except Exception as e:
            logger.warning(f"Failed to initialize CalendarService: {e}")

    def create_meeting_event(self, 
                             title: str, 
                             start_time: datetime.datetime, 
                             duration_minutes: int, 
                             description: str = "",
                             attendees: list = []) -> Dict[str, Any]:
        """
        Creates a Google Calendar event with a Google Meet link.
        Returns the full event object (including hangoutLink).
        """
        if not self.service:
            logger.error("Calendar service is not available.")
            return {}

        end_time = start_time + datetime.timedelta(minutes=duration_minutes)

        event = {
            'summary': title,
            'description': description,
            'start': {
                'dateTime': start_time.isoformat(),
                'timeZone': 'UTC',
            },
            'end': {
                'dateTime': end_time.isoformat(),
                'timeZone': 'UTC',
            },
            'attendees': [{'email': email} for email in attendees],
            'conferenceData': {
                'createRequest': {
                    'requestId': str(uuid.uuid4()),
                    'conferenceSolutionKey': {'type': 'hangoutsMeet'}
                }
            },
        }

        try:
            # conferenceDataVersion=1 is REQUIRED for creating Meet links
            created_event = self.service.events().insert(
                calendarId='primary', 
                body=event, 
                conferenceDataVersion=1
            ).execute()
            
            logger.info(f"Event created: {created_event.get('htmlLink')}")
            return created_event
        
        except Exception as e:
            logger.error(f"Error creating calendar event: {e}")
            return {}

# Singleton instance
calendar_service = CalendarService()
