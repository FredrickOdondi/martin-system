from google.oauth2 import service_account
import google.auth
from googleapiclient.discovery import build
import logging
import os
from app.core.config import settings
from typing import Dict, Any, Optional
import uuid
import datetime

logger = logging.getLogger(__name__)

class CalendarService:
    SCOPES = ['https://www.googleapis.com/auth/calendar']

    def __init__(self):
        self.creds = None
        self.service = None
        self._credentials_valid = True  # Track if credentials are working
        self._last_error_logged = None  # Prevent spam
        # We now initialize lazily on first use to avoid race conditions with startup credentials restoration

    def _initialize_service(self):
        if self.service:
            return True
        try:
            # 1. Try OAuth2 User Token (generated by setup_google_auth.py)
            # Note: token.json is restored by app.core.google_utils.setup_google_credentials() on startup
            if os.path.exists('token.json'):
                from google.oauth2.credentials import Credentials
                from google.auth.transport.requests import Request
                
                self.creds = Credentials.from_authorized_user_file('token.json', self.SCOPES)
                
                # Auto-refresh token if expired
                if self.creds and self.creds.expired and self.creds.refresh_token:
                    logger.info("OAuth token expired. Refreshing...")
                    try:
                        self.creds.refresh(Request())
                        
                        # Save refreshed token back to file
                        with open('token.json', 'w') as token:
                            token.write(self.creds.to_json())
                        
                        logger.info(f"âœ“ Token refreshed successfully. New expiry: {self.creds.expiry}")
                    except Exception as refresh_error:
                        logger.error(f"Failed to refresh token: {refresh_error}")
                        logger.warning("Calendar service will not function until token is manually refreshed.")
                        self._credentials_valid = False
                        return False
                
                self.service = build('calendar', 'v3', credentials=self.creds)
                logger.info("CalendarService initialized via token.json.")
                return True
            
            # 2. Start Service Account Logic
            else:
                # Try to grab default credentials (cloud or local ADC)
                # For Service Account, GOOGLE_APPLICATION_CREDENTIALS should be set
                try:
                    self.creds, project = google.auth.default(scopes=self.SCOPES)
                except Exception as auth_error:
                    logger.debug(f"Default credentials not found: {auth_error}")
                    return False
                
                # Check for impersonation (Domain-Wide Delegation)
                # Required for Service Accounts to generate Meet links (needs Workspace license)
                impersonate_email = os.environ.get("GOOGLE_IMPERSONATE_EMAIL")
                if impersonate_email and hasattr(self.creds, 'with_subject'):
                    logger.info(f"Impersonating user: {impersonate_email}")
                    self.creds = self.creds.with_subject(impersonate_email)

                self.service = build('calendar', 'v3', credentials=self.creds)
                logger.info("CalendarService initialized via Service Account.")
                return True
        except Exception as e:
            logger.debug(f"CalendarService initialization deferred: {e}")
            return False
    def create_meeting_event(self, 
                             title: str, 
                             start_time: datetime.datetime, 
                             duration_minutes: int, 
                             description: str = "",
                             attendees: list = [],
                             meeting_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Creates a Google Calendar event with a Google Meet link.
        Returns the full event object (including hangoutLink).
        """
        if not self._initialize_service():
            logger.error("Calendar service is not initialized.")
            return {}

        end_time = start_time + datetime.timedelta(minutes=duration_minutes)

        event = {
            'summary': title,
            'description': description,
            'start': {
                'dateTime': start_time.isoformat(),
                'timeZone': 'UTC',
            },
            'end': {
                'dateTime': end_time.isoformat(),
                'timeZone': 'UTC',
            },
            'attendees': [{'email': email} for email in attendees],
            'conferenceData': {
                'createRequest': {
                    'requestId': str(uuid.uuid4()),
                    'conferenceSolutionKey': {'type': 'hangoutsMeet'}
                }
            },
        }

        if meeting_id:
            event['extendedProperties'] = {
                'private': {
                    'meeting_id': str(meeting_id)
                }
            }

        try:
            # conferenceDataVersion=1 is REQUIRED for creating Meet links
            # sendUpdates='none' prevents Google from sending its own email invites
            created_event = self.service.events().insert(
                calendarId='primary', 
                body=event, 
                conferenceDataVersion=1,
                sendUpdates='none' 
            ).execute()
            
            logger.info(f"Event created: {created_event.get('htmlLink')}")
            return created_event
        
        except Exception as e:
            logger.error(f"Error creating calendar event: {e}")
            return {}

    def get_meeting_rsvps(self, meeting_id: str) -> Dict[str, str]:
        """
        Retrieves RSVP status for a given meeting ID by searching extended properties.
        Returns a dict mapping email -> status.
        Status values: 'accepted', 'declined', 'needsAction', 'tentative'
        """
        if not self._initialize_service():
            return {}

        # Skip if we know credentials are invalid to avoid spam
        if not self._credentials_valid:
            return {}

        try:
            # Search for event with privateExtendedProperty meeting_id=<id>
            events_result = self.service.events().list(
                calendarId='primary',
                privateExtendedProperty=f"meeting_id={meeting_id}",
                singleEvents=True
            ).execute()

            events = events_result.get('items', [])
            if not events:
                logger.debug(f"No calendar event found for meeting_id {meeting_id}")
                return {}

            # Should only be one event
            event = events[0]
            attendees = event.get('attendees', [])
            
            rsvps = {}
            for attendee in attendees:
                email = attendee.get('email')
                status = attendee.get('responseStatus')
                if email and status:
                    rsvps[email] = status
                    
            return rsvps

        except Exception as e:
            error_str = str(e)
            # Check if it's a credential error
            if 'invalid_grant' in error_str or 'expired' in error_str.lower() or 'revoked' in error_str.lower():
                # Only log once
                if self._credentials_valid:
                    logger.warning("Google Calendar credentials are expired or revoked. RSVP sync disabled until re-authentication.")
                    self._credentials_valid = False
            else:
                # Log other errors normally
                logger.error(f"Error fetching RSVPs for meeting {meeting_id}: {e}")
            return {}

    def add_attendees_to_event(self, meeting_id: str, new_emails: list) -> bool:
        """
        Adds attendees to an existing Google Calendar event found by meeting_id.
        """
        if not self._initialize_service():
            return False

        try:
            # 1. Find the event
            events_result = self.service.events().list(
                calendarId='primary',
                privateExtendedProperty=f"meeting_id={meeting_id}",
                singleEvents=True
            ).execute()

            events = events_result.get('items', [])
            if not events:
                logger.warning(f"No calendar event found for meeting_id {meeting_id} to add attendees")
                return False

            event = events[0]
            event_id = event['id']
            
            # 2. Get existing attendees
            existing_attendees = event.get('attendees', [])
            existing_emails = {a.get('email') for a in existing_attendees}
            
            # 3. Append new ones
            updated = False
            for email in new_emails:
                if email and email not in existing_emails:
                    existing_attendees.append({'email': email})
                    updated = True
            
            if not updated:
                return True

            event['attendees'] = existing_attendees
            
            # 4. Patch the event
            # Ensure we don't send updates (since we sent our own email)
            self.service.events().patch(
                calendarId='primary',
                eventId=event_id,
                body={'attendees': existing_attendees},
                sendUpdates='none'
            ).execute()
            
            logger.info(f"Added {len(new_emails)} attendees to event {event_id}")
            return True

        except Exception as e:
            logger.error(f"Error adding attendees to meeting {meeting_id}: {e}")
            return False

    def update_meeting_event(self, meeting_id: str, new_start_time: datetime.datetime = None, 
                             new_duration_minutes: int = None, new_location: str = None) -> bool:
        """
        Updates an existing Google Calendar event's time or location.
        Used when conflicts are resolved via auto-negotiation.
        """
        if not self._initialize_service():
            logger.warning("Calendar service not available for update.")
            return False

        if not self._credentials_valid:
            logger.warning("Calendar credentials invalid, skipping event update.")
            return False

        try:
            # 1. Find the event by meeting_id
            events_result = self.service.events().list(
                calendarId='primary',
                privateExtendedProperty=f"meeting_id={meeting_id}",
                singleEvents=True
            ).execute()

            events = events_result.get('items', [])
            if not events:
                logger.warning(f"No calendar event found for meeting_id {meeting_id} to update")
                return False

            event = events[0]
            event_id = event['id']
            
            # 2. Build patch body
            patch_body = {}
            
            if new_start_time:
                # Calculate end time based on duration
                duration = new_duration_minutes or 60  # Default 60 mins if not specified
                end_time = new_start_time + datetime.timedelta(minutes=duration)
                
                patch_body['start'] = {
                    'dateTime': new_start_time.isoformat(),
                    'timeZone': 'UTC'
                }
                patch_body['end'] = {
                    'dateTime': end_time.isoformat(),
                    'timeZone': 'UTC'
                }
                
            if new_location:
                patch_body['location'] = new_location
            
            if not patch_body:
                logger.info("No changes to apply to calendar event")
                return True
            
            # 3. Patch the event
            self.service.events().patch(
                calendarId='primary',
                eventId=event_id,
                body=patch_body,
                sendUpdates='all'  # Send notification to attendees
            ).execute()
            
            logger.info(f"Updated calendar event {event_id} for meeting {meeting_id}")
            return True

        except Exception as e:
            error_str = str(e)
            if 'invalid_grant' in error_str or 'expired' in error_str.lower():
                if self._credentials_valid:
                    logger.warning("Google Calendar credentials expired during update.")
                    self._credentials_valid = False
            else:
                logger.error(f"Error updating calendar event for meeting {meeting_id}: {e}")
            return False

    def cancel_meeting_event(self, meeting_id: str) -> bool:
        """
        Cancels a Google Calendar event (sets status to 'cancelled').
        """
        if not self._initialize_service() or not self._credentials_valid:
            return False

        try:
            events_result = self.service.events().list(
                calendarId='primary',
                privateExtendedProperty=f"meeting_id={meeting_id}",
                singleEvents=True
            ).execute()

            events = events_result.get('items', [])
            if not events:
                logger.warning(f"No calendar event found for meeting_id {meeting_id} to cancel")
                return False

            event_id = events[0]['id']
            
            self.service.events().delete(
                calendarId='primary',
                eventId=event_id,
                sendUpdates='all'  # Notify attendees of cancellation
            ).execute()
            
            logger.info(f"Cancelled calendar event {event_id} for meeting {meeting_id}")
            return True

        except Exception as e:
            logger.error(f"Error cancelling calendar event for meeting {meeting_id}: {e}")
            return False

# Singleton instance
calendar_service = CalendarService()

